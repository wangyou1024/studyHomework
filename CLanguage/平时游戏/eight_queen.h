//八皇后总体思路：将64个位置看做64个坐标，以左下角为原点，x轴为1-8，Y轴为1-8。
//设一个大数组，存入已经选择的坐标以及不合法的坐标（在选择的坐标的横竖斜线上都为不合法坐标）
//进入下一行选择时，从1-8依次检查坐标不否合法，合法就可以按选定，并将新的不合法坐标加入数组。
//一次排放正确，依次返回上层重新选择，返回上层时要清除数组中新加入的不合法坐标（每次加入新不合法坐标时用一个小数组存储加入的内容，清除时即是将大数组中与小数组相同的坐标归零）
//检查坐标是否合法，a为大数组，b为被检查坐标
int check(int (*a)[2],int b[2])
{
	int i=0,j=0;
	//依次查看大数组中是否有被检查坐标
	for(i=0;i<64;i++)
	{
		if(*(*(a+i))==b[0] && *(*(a+i)+1)==b[1])
		{
			//有则返回1;
			j=1;
			break;
		}
	}
	//没有则返回2。
	if(i==64)
		j=2;
	return j;
}
//返回上层，a为大数组，c为每层小数组
void back(int (*a)[2],int (*c)[2])
{
	int i=0,j=0;
	//寻找大数组与小数组中相同的坐标
	for(i=0;i<64;i++)
	{
		for(j=0;j<25;j++)
		{
			//找到后将它们都归零即删除
			if(*(*(a+i))==*(*(c+j)) && *(*(a+i)+1)==*(*(c+j)+1))
			{
				*(*(a+i))=0;
				*(*(c+j))=0;
				*(*(a+i)+1)=0;
				*(*(c+j)+1)=0;
				break;
			}
		}
	}
}
//加入不合法坐标，a为大数组，d为小数组，f为选定的坐标
void entermore(int (*a)[2],int (*d)[2],int f[2])
{
	int i=0,j=0,x=1,y=1;
	int e[2];
	//一个坐标选定后，该坐标的一行都为不合法坐标；
	for(x=1;x<9;x++)
	{
		e[0]=x;
		e[1]=f[1];
		if(check(a,e)==2)
		{
			*(*(d+i))=x;
			*(*(d+i)+1)=f[1];
			i++;
			for(j=0;j<64;j++)
			{
				if(*(*(a+j))==0)
				{
					*(*(a+j))=x;
					*(*(a+j)+1)=f[1];
					break;
				}
			}
		}
	}
	//该坐标的一列也都为不合法坐标
	for(y=f[1],x=f[0];y<9;y++)
	{
		e[0]=f[0];
		e[1]=y;
		if(check(a,e)==2)
		{
			*(*(d+i))=x;
			*(*(d+i)+1)=y;
			i++;
			for(j=0;j<64;j++)
			{
				if(*(*(a+j))==0)
				{
					*(*(a+j))=x;
					*(*(a+j)+1)=y;
					break;
				}
			}
		}
	}
	//该坐标的左斜方向
	for(x=f[0],y=f[1];x>0 && y<9;x--,y++)
	{
		e[0]=x;
		e[1]=y;
		if(check(a,e)==2)
		{
			*(*(d+i))=x;
			*(*(d+i)+1)=y;
			i++;
			for(j=0;j<64;j++)
			{
				if(*(*(a+j))==0)
				{
					*(*(a+j))=x;
					*(*(a+j)+1)=y;
					break;
				}
			}
		}
	}
	//该坐标的右斜方向都为不合法坐标
	for(x=f[0],y=f[1];x<9 && y<9;x++,y++)
	{
		e[0]=x;
		e[1]=y;
		if(check(a,e)==2)
		{
			*(*(d+i))=x;
			*(*(d+i)+1)=y;
			i++;
			for(j=0;j<64;j++)
			{
				if(*(*(a+j))==0)
				{
					*(*(a+j))=x;
					*(*(a+j)+1)=y;
					break;
				}
			}
		}
	}
}
void for_result()
{
	FILE *fp;
	double have;
	int h;
	int result[8][2],result1[2],result2[2],result3[2],result4[2],result5[2],result6[2],result7[2],result8[2];//选定的八个坐标
	int i1,i2,i3,i4,i5,i6,i7,i8,i,j=1;//每层需要经过八次循环，且层层包含
	int a[64][2]={0},a1[25][2]={0},a2[25][2]={0},a3[25][2]={0},a4[25][2]={0},a5[25][2]={0},a6[25][2]={0},a7[25][2]={0},a8[25][2]={0};//a为大数组，其它的为每层的小数组
	int (*allnumber)[2]=a,(*back1)[2]=a1,(*back2)[2]=a2,(*back3)[2]=a3,(*back4)[2]=a4,(*back5)[2]=a5,(*back6)[2]=a6,(*back7)[2]=a7,(*back8)[2]=a8;//用指针来操作数组更方便
	if ((fp=fopen("E:\\eightqueen.txt","w+"))==NULL)
	{
		printf("File open failed!");
		exit(0);
	}
	printf("正在写入文件，已加载00.00%%");
	//第一层
	for(i1=1;i1<9;i1++)
	{
		result1[0]=i1;
		result1[1]=1;
		result[0][0]=result1[0];
		result[0][1]=1;
		entermore(allnumber,back1,result1);//无需检查，直接加入大数组
		//第二层
		for(i2=1;i2<9;i2++)
		{
			result2[0]=i2;
			result2[1]=2;
			//经过检查是否合法后才能进行下一步操作，
			if(check(allnumber,result2)==2)
			{
				result[1][0]=result2[0];
				result[1][1]=2;
				entermore(allnumber,back2,result2);//加入不合法坐标，并为返回上层作准备
				//第三层同理
				for(i3=1;i3<9;i3++)
				{
					result3[0]=i3;
					result3[1]=3;
					if(check(allnumber,result3)==2)
					{
						result[2][0]=result3[0];
						result[2][1]=3;
						entermore(allnumber,back3,result3);
						//第四层同理
						for(i4=1;i4<9;i4++)
						{
							result4[0]=i4;
							result4[1]=4;
							if(check(allnumber,result4)==2)
							{
								result[3][0]=result4[0];
								result[3][1]=4;
								entermore(allnumber,back4,result4);
								//第五层同理
								for(i5=1;i5<9;i5++)
								{
									result5[0]=i5;
									result5[1]=5;
									if(check(allnumber,result5)==2)
									{
										result[4][0]=result5[0];
										result[4][1]=5;
										entermore(allnumber,back5,result5);
										//第六层同理
										for(i6=1;i6<9;i6++)
										{
											result6[0]=i6;
											result6[1]=6;
											if(check(allnumber,result6)==2)
											{
												result[5][0]=result6[0];
												result[5][1]=6;
												entermore(allnumber,back6,result6);
												//第七层同理
												for(i7=1;i7<9;i7++)
												{
													result7[0]=i7;
													result7[1]=7;
													if(check(allnumber,result7)==2)
													{
														result[6][0]=result7[0];
														result[6][1]=7;
														entermore(allnumber,back7,result7);
														//第八层/最后一层
														for(i8=1;i8<9;i8++)
														{
															result8[0]=i8;
															result8[1]=8;
															//判断合法后即完成一次正确的排放
															if(check(allnumber,result8)==2)
															{
																result[7][0]=result8[0];
																result[7][1]=8;
																entermore(allnumber,back8,result8);
																fprintf(fp,"%-2d.",j);
																j++;
																for(i=0;i<8;i++)
																{
																	fprintf(fp,"(%d %d)",*(*(result+i)),*(*(result+i)+1));
																}
																fprintf(fp,"\n");
																for(i=0;i<8;i++)
																{
																	for(h=1;h<9;h++)
																	{
																		if(*(*(result+i))==h)
																			fprintf(fp,"1  ");
																		else
																			fprintf(fp,"0  ");
																	}
																	fprintf(fp,"\n");
																}
																fprintf(fp,"\n");
																printf("\b\b\b\b\b\b");
																have=j/92.0*100;
																printf("%5.2lf%%",have);
																Sleep(50);
																//返回第七层时清除第八层执行的痕迹，重新进行一次选择，产生只有最后一位不同的排放方式
																back(allnumber,back8);
															}	
														}
														//返回第六层，清除六层后的执行痕迹，在第七层选择另一个坐标，然后进入下一层，
														back(allnumber,back7);
													}
												}
												//同理
												back(allnumber,back6);
											}
										}
										//同理
										back(allnumber,back5);
									}
								}
								//同理
								back(allnumber,back4);
							}
						}
						//同理
						back(allnumber,back3);
					}
				}
				//同理
				back(allnumber,back2);
			}
		}
		//同理
		back(allnumber,back1);
	}
	fclose(fp);
	printf("\r");
	printf("加载完成，请打开E:\\\\eightqueen.txt文件\n");
}
